{"index":"{\"keys\":[{\"path\":[\"title\"],\"id\":\"title\",\"weight\":1,\"src\":\"title\",\"getFn\":null},{\"path\":[\"desc\"],\"id\":\"desc\",\"weight\":1,\"src\":\"desc\",\"getFn\":null},{\"path\":[\"body\"],\"id\":\"body\",\"weight\":1,\"src\":\"body\",\"getFn\":null}],\"records\":[{\"i\":0,\"$\":{\"0\":{\"v\":\"[Git] git 이전 브랜치로 되돌아가기\",\"n\":0.447},\"2\":{\"v\":\"\\n## 이전 브랜치로 되돌아가기\\n\\n```bash\\ngit checkout @{-1}\\n```\\n\\n`git checkout @{-n}` n단계 이전의 브랜치로 돌아가는 명령어다.\\n\\n## 더 간단하게는.\\n\\n```bash\\ngit checkout -\\n```\\n\\n@{-1}를 -로 축약해서 사용 가능하다.\\n\\n> 두 브랜치를 병행하여 작업하는 경우가 많은데 이 떄 `git checkout -`를 이용하자.\\n\",\"n\":0.174}}},{\"i\":1,\"$\":{\"0\":{\"v\":\"[Javascript] ES6 import/export 구문 정리\",\"n\":0.447},\"1\":{\"v\":\"ES6 import/export 구문 정리\",\"n\":0.5},\"2\":{\"v\":\"\\nes6모듈 import/export 내용이다. (commonjs import/export 정리는 따로)\\n\\n## Default import/export vs Name import/export\\n\\n### Default import/export\\n\\nexport default는 이름이 필요없다. 따라서 import 시 원하는 변수명으로 가져오면 된다.\\n\\n```js\\n/// personInfo.js\\n\\n// default export\\nexport default {\\n    name: '아무개',\\n    age: 22,\\n}\\n\\n...\\n\\n// ✔ default를 import시 변수명을 임의로 정할 수 있다.\\nimport personInfo from './personInfo.js'\\nconsole.log(personInfo) // { name: '아무개', age: 22 }\\n\\n// ✔ Import All 문법 사용 시 export default 정보는 'default'속성으로 접근할 수 있다.\\nimport * as personInfo from './personInfo.js'\\nconsole.log(personInfo.default) // { name: '아무개', age: 22 }\\n\\n// ❌ default의 속성 정보는 객체 구조 분해 할당을 통해서 가져올 수 없다. (일반 객체에서 가져오는 것과 문법이 다름)\\nimport { name, age } from './personInfo.js' // Error\\n```\\n\\n### Name import/export\\n\\n#### Name export\\n\\n```js\\n/// colorInfo.js\\n\\n// name export 방법 1\\nexport const hex = '#fff'\\nexport const name = 'white'\\n\\n// name export 방법 2\\nconst hex = '#fff'\\nconst name = 'white'\\n\\nexport {\\n    hex, // hex: '#fff', 처럼 선언 불가\\n    name,\\n}\\n\\n// ❌ 잘못된 name export 방법\\nexport {\\n    hex: '#fff', // ❌\\n    name: 'white', // ❌\\n}\\n\\n// export 뒷 {} 내용은 일반 객체가 아니다.\\n// 변수명만 콤마로 나열할 수 있다.\\n\\n```\\n\\n#### Name import\\n\\n```js\\n// ✔ Name import/export는 중괄호로 묶어서 가져온다.\\nimport { hex, name } from \\\"./colorInfo.js\\\"\\nconsole.log(hex, name) // #fff white\\n\\n// alias를 주어 변경된 명칭으로 할당할 수 있다.\\nimport { hex as color, name } from \\\"./colorInfo.js\\\"\\nconsole.log(color, name) // #fff white\\n\\n// ✔ Import All 문법으로 가져올 수 있다.\\nimport * as colorInfo from \\\"./colorInfo.js\\\"\\nconsole.log(colorInfo.hex, colorInfo.name) // #fff, white\\n\\n// ❌Default Export를 가져오는 방식이므로 Error\\nimport moduleWithName from \\\"./colorInfo.js\\\" // The requested module './colorInfo.js' does not provide an export named 'default'\\n```\\n\\n### Default import/export, Name import/export 혼합 예제\\n\\n```js\\n/// mix.js\\nexport const hex = '#fff'\\nexport const name = 'white'\\n\\nexport default {\\n    name: '아무개',\\n    age: 22,\\n}\\n...\\n\\nimport personInfo, { hex, name } from './mix.js' // ✔ personInfo는 default, 그외 Name Export와 연결된다.\\nconsole.log(personInfo.name) // 홍길동\\nconsole.log(personInfo.age) // 22\\nconsole.log(hex, name) // #fff white\\n\\n// ✔\\nimport * as test from './mix.js'\\nconsole.log(test.default.name) //  무개\\nconsole.log(test.name) // white\\n```\\n\",\"n\":0.059}}},{\"i\":2,\"$\":{\"0\":{\"v\":\"[Git] git 원격 브랜치 삭제\",\"n\":0.447},\"2\":{\"v\":\"\\n## 삭제할 원격 브랜치 조회\\n\\n```bash\\ngit branch -r\\n: '\\n  origin/HEAD -> origin/master\\n  origin/develop\\n  origin/features/add-something # 삭제 대상\\n  origin/master\\n'\\n```\\n\\n## 원격 브랜치 삭제\\n\\n```bash\\ngit push origin --delete features/add-something\\n```\\n\\n### 기타\\n\\n실제 원격에 없는데 `git branch -r`에서 조회되는 경우\\n\\n```bash\\ngit fetch -p # 로컬 캐시 Clear\\n```\\n\",\"n\":0.162}}},{\"i\":3,\"$\":{\"0\":{\"v\":\"[Javascript] 배열 내 중복된 정보 추출하기\",\"n\":0.408},\"2\":{\"v\":\"\\n배열 내 중복된 요소 가져오기\\n\\n```js\\n// target\\nconst strArray = [\\\"q\\\", \\\"w\\\", \\\"w\\\", \\\"w\\\", \\\"e\\\", \\\"i\\\", \\\"u\\\", \\\"r\\\"]\\n\\n// 첫번째 인자값만 가져오는 indexOf를 통해 필터링하기\\nconst findDuplicates = arr =>\\n  arr.filter((item, index) => arr.indexOf(item) !== index)\\nconst duplicatedItems = [...new Set(findDuplicates(strArray))]\\n```\\n\",\"n\":0.167}}},{\"i\":4,\"$\":{\"0\":{\"v\":\"[Javascript] JSON stringify undefined 속성값 관련\",\"n\":0.408},\"2\":{\"v\":\"\\n```js\\nconst params = {\\n  a: 1,\\n  b: 2,\\n  c: null,\\n  d: undefined,\\n}\\nconst result = JSON.stringify(params)\\n\\nconsole.log(result) // {\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":null}\\n```\\n\\n위의 params 객체에서 stringify할 때 값이 `undefined`인 `d` 속성은 결과 값에 나오지 않는다.\\n\\n물론 아래와 같이 parsing하여 결과를 가져오면 같은 같은 값이 나온다.\\n\\n```js\\nconst params = {\\n  a: 1,\\n  b: 2,\\n  c: null,\\n  d: undefined,\\n}\\nconst result = JSON.stringify(params)\\n\\nconst parsedData = JSON.parse(result)\\nconsole.log(params.d) // undefined\\nconsole.log(parsedData.d) // undefined\\n```\\n\\n문제는 APi 서버에서 d 속성이 없어서 에러가 났다.\\n\\n해결, JSON.stringify 두번째 인자로 replacer 함수를 넣어 원하는 대로 값으로 변경하면 된다.\\n\\n```js\\nconst replacer = (key, value) => (typeof value === \\\"undefined\\\" ? null : value) // undefined to null\\nconst params = {\\n  a: 1,\\n  b: 2,\\n  c: null,\\n  d: undefined,\\n}\\nconst result = JSON.stringify(params, replacer)\\n\\nconsole.log(result) // {\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":null,\\\"d\\\":null}\\n```\\n\",\"n\":0.095}}},{\"i\":5,\"$\":{\"0\":{\"v\":\"[Javascript] IIFE란\",\"n\":0.707},\"2\":{\"v\":\"\\n`Immediately Invoked Function Expressions`의 약어로 즉시실행 함수를 뜻한다.\\n\\n```js\\nfunction () {\\n    // 내용\\n}\\n```\\n\\n> 선언한 함수에\\n\\n```js\\n;(function () {\\n  // 내용\\n})() // invoke\\n```\\n\\n> 소괄호로 묶어 바로 실행하는 표현식이다.\\n\\nes6문법이 나오기 전에는 `var`키워드를 통해 변수를 선언했는데\\\\\\nvar 스코프가 `Function Scope`였으므로 전역 영역을 오염시키기 쉬웠다.\\\\\\n전역 영역 오염을 방지하고 캡슐화하기 위해 많이 사용했다.\\n\\n지금은 es6문법 `Block Scope`인 `let` `const` 키워드가 나와서\\\\\\nIIFE문법은 잘 사용하지 않는 듯 하다.\\n\\nJquery 라이브러리 예시\\n\\n```js\\n/// https://code.jquery.com/jquery-3.6.1.js\\n;(function (global, factory) {\\n  \\\"use strict\\\"\\n\\n  if (typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\") {\\n    module.exports = global.document\\n      ? factory(global, true)\\n      : function (w) {\\n          if (!w.document) {\\n            throw new Error(\\\"jQuery requires a window with a document\\\")\\n          }\\n          return factory(w)\\n        }\\n  } else {\\n    factory(global)\\n  }\\n\\n  // Pass this if window is not defined yet\\n})(\\n  typeof window !== \\\"undefined\\\" ? window : this,\\n  function (window, noGlobal) {}\\n)\\n```\\n\",\"n\":0.088}}},{\"i\":6,\"$\":{\"0\":{\"v\":\"[Javascript] Array.slice.call 그리고 Array.from\",\"n\":0.5},\"2\":{\"v\":\"\\n개발하다 이상한 문법을 발견했다.\\n\\n```js\\nfunction testFunction () {\\n    console.log(arguments) // Array Like Object\\n    console.log([].slice.call(arguments)) // [1, 2, 3, 4, 5]\\n    console.log(Array.prototype.slice.call(arguments)) // [1, 2, 3, 4, 5]\\n\\n    ...\\n}\\n\\ntestFunction(1,2,3,4,5) // [1, 2, 3, 4, 5]\\n```\\n\\nslice.call을 사용하더라\\n\\n## 이유\\n\\n`arguments`를 배열처럼 다루기 위해 Array.slice()를 이용한 것이다.\\\\\\n`arguments`는 유사배열이며 실제 배열이 아니라\\\\\\n`forEach()`, `map()`, `reduce()`와 같은 Array 인스턴스함수를 사용하지 못한다.\\n\\n하지만 arguments 는 유사배열이므로 `[].fn.call(arguments, ...)`를 이용해서 함수를 호출할 수 있다.\\n\\n여기서 Array.slice()는 새로운 배열 객체를 반환해주므로 반환된 객체를 이용하려고 사용한 것이다. ([MDN Array.slice()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice))\\n\\n## ES6\\n\\nES6문법이 생기고 나서는 `slice.call()`를 이용할 필요가 없어졌다.\\\\\\n유사배열을 새로운 객체로 반환해주는 `Array.from()`함수가 생겼다. ([MDN Array.from()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from))\\\\\\n또는 스프레드 연산자(...)으로도 대체 가능하다. ([MDN ...](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax))\\n\\n```js\\nfunction testFunction() {\\n  console.log(arguments) // Array Like Object\\n  console.log(Array.from(arguments)) // [1, 2, 3, 4, 5]\\n  console.log([...arguments]) // [1, 2, 3, 4, 5]\\n}\\n```\\n\",\"n\":0.093}}},{\"i\":7,\"$\":{\"0\":{\"v\":\"[Javascript] DOM Element 속성 출력하기\",\"n\":0.447},\"2\":{\"v\":\"\\n## 문제\\n\\ndocument.querySelector('div')로 어떤 속성이 있는지 파악하기 위해\\\\\\n`Object.keys()`를 이용해 출력을 해보았다.\\n\\n```js\\nconst $div = document.querySelector(\\\"div\\\")\\nObject.keys($div) // []\\n```\\n\\n$div 객체가 값이 있는데도 style이나 dataset 속성들이 출력되지 않았다.\\n\\n## 원인\\n\\n[MDN Object.keys()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)에 의하면\\\\\\n주어진 객체 자신의(프로토타입 제외) 열거가능한 속성만 배열로 반환한다고 나와있다.\\n\\n정리하자면\\n\\n```js\\nconst testObj = {\\n  a: 1,\\n  b: 2,\\n}\\nObject.defineProperty(testObj, \\\"c\\\", {\\n  value: 3,\\n  enumerable: true,\\n})\\nObject.defineProperty(testObj, \\\"d\\\", {\\n  value: 4,\\n  enumerable: false,\\n}) // d 속성은 non enumerable 이므로 출력되지 않음\\n\\nconsole.log(Object.keys(testObj)) // ['a', 'b', 'c']\\n\\nfunction testFunction() {\\n  this.a = 1\\n  this.b = 2\\n}\\ntestFunction.prototype.c = 3 // 프로토타입의 속성이므로 출력되지 않음\\nconsole.log(Object.keys(new testFunction())) // ['a', 'b']\\n```\\n\\n## 해결\\n\\n위 내용들로 볼 때 두가지 문제가 있다.\\n\\n문제\\n\\n- 1.Object.keys는 열거가능한 속성만 가져온다.\\n- 2.프로토타입 정보는 가져오지 않는다.\\n\\n해결\\n\\n- 1.열거 가능한 속성도 출력하는 [Object.getOwnPropertyNames()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)를 사용한다.\\n- 2.[Object.getPrototypeOf()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)함수를 이용한다.\\n\\n```js\\nfunction getAllPropertyKeys(el) {\\n  let obj = []\\n  let target = el\\n  while (true) {\\n    obj = [...obj, ...Object.getOwnPropertyNames(target)]\\n\\n    const proto = Object.getPrototypeOf(target)\\n    if (!proto) break\\n    target = proto\\n  }\\n\\n  return obj\\n}\\n\\nconst $div = document.querySelector(\\\"div\\\")\\nconsole.log(getAllPropertyKeys($div))\\n```\\n\",\"n\":0.085}}},{\"i\":8,\"$\":{\"0\":{\"v\":\"[Javascript] 속성 존재 여부 판단\",\"n\":0.447},\"2\":{\"v\":\"\\nJavascript 객체에 `age`속성이 존재하는지 판단하는 방법\\n\\n### 방법 1. obj.age !== undefined\\n\\n`age`값이 undefined일 수 없다는 가정하에 사용 가능하다.\\n\\n```js\\nfunction existsAgeProp(obj) {\\n  return obj.age !== undefined\\n}\\n\\nconst person = { name: \\\"김\\\" }\\nconsole.log(existsAgeProp(person)) // false\\n\\n///////////////////////\\n\\n// age값이 undefined일 경우\\nconst person2 = { name: \\\"김\\\", age: undefined }\\nconsole.log(existsAgeProp(person2)) // false, ❌ age속성이 있는데 결과는 없다고 나온다.\\n```\\n\\n### 방법 2. obj.hasOwnProperty('age')\\n\\nObject.prototype.hasOwnProperty() 함수를 사용한다.\\\\\\n메서드 명에 `Own`이 들어간 것과 같이 프로토타입 속성들까지 체크하지 않는다.\\n\\n```js\\nfunction existsAgeProp(obj) {\\n  return obj.hasOwnProperty(\\\"age\\\")\\n}\\n\\nconst person = { name: \\\"김\\\" }\\nconsole.log(existsAgeProp(person)) // false\\n\\n// age값이 undefined인 경우\\nconst person2 = { name: \\\"김\\\", age: undefined }\\nconsole.log(existsAgeProp(person2)) // true\\n\\n///////////////////////\\n\\nconst person3 = {\\n  name: \\\"김\\\",\\n  __proto__: {\\n    age: 16,\\n  },\\n}\\nconsole.log(existsAgeProp(person3)) // false, 프로토타입 속성은 체크하지 않는다.\\n```\\n\\n### 방법 3. 'age' in obj\\n\\n해당 객체와 프로토타입 체인 내 모든 속성들까지 모두 검증하려면 `in` 연산자를 사용한다.\\n\\n```js\\nfunction existsAgeProp(obj) {\\n  return \\\"age\\\" in obj\\n}\\n\\nconst person = { name: \\\"김\\\" }\\nconsole.log(existsAgeProp(person)) // false\\n\\n// age값이 undefined인 경우\\nconst person2 = { name: \\\"김\\\", age: undefined }\\nconsole.log(existsAgeProp(person2)) // true\\n\\nconst person3 = {\\n  name: \\\"김\\\",\\n  __proto__: {\\n    age: 16,\\n  },\\n}\\nconsole.log(existsAgeProp(person3)) // true\\n```\\n\",\"n\":0.079}}},{\"i\":9,\"$\":{\"0\":{\"v\":\"[Javascript] UTC 관련 날짜 정리 (with moment.js)\",\"n\":0.378},\"2\":{\"v\":\"\\n날짜 관련해서 헷갈리는 부분을 정리해보았다.\\n\\nGMT란 `Greenwich Mean Time`의 약어로 그리니치 평균시를 뜻한다.\\\\\\n영군 런던에 소재한 그리니치 천문대를 기점으로 정했다. GMT(+0)\\n\\n> GMT+0은 Z로 표기한다. (Zulu Time)\\\\\\n> 한국은 `GMT+9` 이다.\\n\\nUTC(`Universal Time Coordinated`)는 협정 세계시를 뜻한다.\\\\\\nUTC는 GMT에 기반하므로 GMT라 불리기도 하는데\\\\\\n기술적인 표기로 `UTC`가 맞다.\\n\\n> 실제 UTC와 GMT의 차이는 밀리초정도만 차이난다.\\\\\\n> 한국은 `UTC+9` 이다. (GMT와 동일)\\n\\n## 애매모호한 부분\\n\\n```js\\nconsole.log(new Date(\\\"2022-09-05\\\").toISOString()) // 2022-09-05T00:00:00.000Z // UTC+0\\nconsole.log(new Date(\\\"2022/09/05\\\").toISOString()) // 2022-09-04T15:00:00.000Z // localTime\\n```\\n\\n파싱할 문자열에 UTC 정보가 없을 경우, `-`으로 구분하냐 `/`으로 구분하냐에 따라 시간대 정보가 다르게 출력된다.\\n\\nISO 표준은 UTC 관련정보가 없으면(Z 또는 +00:00)\\\\\\n`local time`으로 가정한다고 나와있다. ([ISO_8601](<https://en.wikipedia.org/wiki/ISO_8601#Local_time_(unqualified)>))\\n\\n하지만 ES5에선 `UTC+0`로 가정한다.\\n\\n하이픈(`-`)으로 구분된 문자는 되도록 ECMA 표준을 따르지만 그 외에는 ISO 표준을 따르고 있다.\\n\\n이런 부분이 애매모호해서 그런지\\\\\\n`moment.js`에서는 `-`이든 `/`이든 ISO 기준으로 출력한다. (UTC 정보가 없을 경우 Local Time 기준으로)\\n\\n```js\\nconsole.log(moment(\\\"2022-09-05\\\").format()) // 2022-09-05T00:00:00+09:00\\nconsole.log(moment(\\\"2022/09/05\\\").format()) // 2022-09-05T00:00:00+09:00\\n```\\n\\n다만 `UTC+0` 기준으로 표기하고 싶을 때엔 `utc`를 활용한다.\\n\\n```js\\nconsole.log(moment.utc(\\\"2022-09-05\\\").format()) // 2022-09-05T00:00:00Z\\n```\\n\\n`local time`으로 표기된 정보를 `utc` 기준으로 보고 싶을 경우에는\\n\\n```js\\nconsole.log(moment(\\\"2022-09-05\\\").utc().format()) // 2022-09-04T15:00:00Z\\n```\\n\",\"n\":0.085}}},{\"i\":10,\"$\":{\"0\":{\"v\":\"CRA - TS & ESLint & prettier 환경 설정 (1)\",\"n\":0.316},\"2\":{\"v\":\"\\nCRA 프로젝트에 eslint와 prettier를 셋업해보자.\\n\\n## 1. CRA typescript 템플릿 설치\\n\\n우선 Create React App 타입스크립트 템플릿으로 프로젝트를 생성한다.\\n\\n```bash\\nyarn create react-app my-app --template typescript\\ncd my-app\\ncode . # vs-code 실행\\n```\\n\\n## 2. ESLint 사전 준비\\n\\n### eslint 모듈 설치\\n\\n```bash\\nyarn add -D eslint\\n```\\n\\n### ESLint Extension 설치\\n\\nvscode extensions에서 `ESLint`를 설치한다.\\n\\n> ESLint환경에선 필수다.\\n\\n## 3. eslintrc 파일 생성\\n\\nESLint를 사용하려면 프로젝트 최상위 폴더에 eslintrc 파일이 있어야 한다.\\\\\\n최상위 폴더에 가서 터미널로 `npm init @eslint/config`를 입력한다.\\n\\n```bash\\nnpm init @eslint/config\\n\\nHow would you like to use ESLint? ...\\n> To check syntax and find problems\\n\\nWhat type of modules does your project use? ...\\n> JavaScript modules (import/export)\\n\\nWhich framework does your project use? ...\\n> React\\n\\nDoes your project use TypeScript?\\n> Yes\\n\\nWhere does your code run? ...  (Press <space> to select, <a> to toggle all, <i> to invert selection)\\n√ Browser\\n√ Node\\n\\nWhat format do you want your config file to be in? ...\\nJavaScript\\n\\neslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest\\nWould you like to install them now with npm?\\nYes\\n```\\n\\nReact와 Typescript를 사용한다고 설정하면 관련 plugin과 parser가 받아진다.\\n\\n> `@typescript-eslint/parser`: 타입스크립트를 linting할 수 있도록 해주는 ESLint 파서\\\\\\n> `@typescript-eslint/eslint-plugin`: 타입스크립트 관련 linting 규칙\\\\\\n> `eslint-plugin-react`: react 관련 linting 규칙\\n\\n아래는 자동 생성된 `.eslintrc.js` 내용이다.\\n\\n```js\\n// .eslintrc.js\\nmodule.exports = {\\n  env: {\\n    browser: true,\\n    es2021: true,\\n    node: true,\\n  },\\n  extends: [\\n    \\\"eslint:recommended\\\",\\n    \\\"plugin:react/recommended\\\",\\n    \\\"plugin:@typescript-eslint/recommended\\\",\\n  ],\\n  parser: \\\"@typescript-eslint/parser\\\",\\n  parserOptions: {\\n    ecmaFeatures: {\\n      jsx: true,\\n    },\\n    ecmaVersion: \\\"latest\\\",\\n    sourceType: \\\"module\\\",\\n  },\\n  plugins: [\\\"react\\\", \\\"@typescript-eslint\\\"],\\n  rules: {},\\n}\\n```\\n\\n## 4. React Hooks API 관련 플러그인 추가\\n\\n추가로 React 16.8버전에 추가된 Hooks API를 사용한다면 별도의 플러그인을 추가로 받는다.\\n\\n```bash\\nyarn add -D eslint-plugin-react-hooks\\n```\\n\\n### .eslintrc.js 수정\\n\\n```js\\nmodule.exports = {\\n  env: {\\n    browser: true,\\n    es2021: true,\\n    node: true,\\n  },\\n  extends: [\\n    \\\"eslint:recommended\\\",\\n    \\\"plugin:react/recommended\\\",\\n    \\\"plugin:@typescript-eslint/recommended\\\",\\n  ],\\n  parser: \\\"@typescript-eslint/parser\\\",\\n  parserOptions: {\\n    ecmaFeatures: {\\n      jsx: true,\\n    },\\n    ecmaVersion: \\\"latest\\\",\\n    sourceType: \\\"module\\\",\\n  },\\n  plugins: [\\n    \\\"react\\\",\\n    \\\"react-hooks\\\", // 추가\\n    \\\"@typescript-eslint\\\",\\n  ],\\n  rules: {\\n    \\\"react/react-in-jsx-scope\\\": \\\"off\\\", // 리액트 17버전 이상은 해당 룰이 의미없으므로 off\\n    \\\"react-hooks/rules-of-hooks\\\": \\\"error\\\", // 추가\\n    \\\"react-hooks/exhaustive-deps\\\": \\\"warn\\\", // 추가\\n  },\\n}\\n```\\n\\n## 5. prettier\\n\\n`prettier`은 소스 내 코드포맷팅을 정해주는 모듈이다.\\\\\\nprettier은 소스 실행과 상관 없이 가이드만 해주는 역할이기 때문에 ESLint와 연동하여 코드포맷팅을 강제하도록 한다.\\n\\n```bash\\nyarn add -D prettier eslint-plugin-prettier eslint-config-prettier\\n```\\n\\n`prettier`: prettier 모듈\\\\\\n `eslint-plugin-prettier`: prettier 관련 linting 규칙\\\\\\n `eslint-config-prettier`: 코드포맷팅 관련 ESLint 룰을 모두 비활성화시킨다. **중요** (충돌방지역할)\\n\\n### prettier Extension 설치\\n\\nvscode extensions에서 `Prettier - Code formatter`를 설치한다.\\n\\n> editor 상에서 밑줄로 prettier 관련 정보를 표시주거나 포맷팅을 도와준다.\\n\\n### prettier 설정\\n\\nprettier를 사용하려면 프로젝트 최상위 폴더에 prettierrc 파일이 있어야 한다.\\\\\\n`prettierrc.json` 를 만들고 아래의 내용을 입력한다.\\n\\n```json\\n{\\n  \\\"useTabs\\\": false,\\n  \\\"tabWidth\\\": 2,\\n  \\\"singleQuote\\\": true,\\n  \\\"printWidth\\\": 120,\\n  \\\"trailingComma\\\": \\\"es5\\\"\\n}\\n```\\n\\n많이 사용하는 기본 옵션이고, 그 외 추가적인 옵션은 [docs](https://prettier.io/docs/en/options.html)를 참고하여 작성한다.\\n\\n> ESLint에서도 포맷팅 관련 설정을 할 수 있는데 prettier와 연동한다면 사용하지 않는 것이 좋다.\\\\\\n> vscode에서 받은 `prettier Extension`은 prettierrc 설정 내용만 보고 포맷팅을 지원해주므로, 소스를 실행하면 에러가 나는데 에디터에서는 에러가 안나는 현상이 발생한다.\\n\\n### .eslintrc.js 수정\\n\\n```js\\nmodule.exports = {\\n  env: {\\n    browser: true,\\n    es2021: true,\\n    node: true,\\n  },\\n  extends: [\\n    \\\"eslint:recommended\\\",\\n    \\\"plugin:react/recommended\\\",\\n    \\\"plugin:prettier/recommended\\\", // 추가\\n    \\\"plugin:@typescript-eslint/recommended\\\",\\n  ],\\n  parser: \\\"@typescript-eslint/parser\\\",\\n  parserOptions: {\\n    ecmaFeatures: {\\n      jsx: true,\\n    },\\n    ecmaVersion: \\\"latest\\\",\\n    sourceType: \\\"module\\\",\\n  },\\n  plugins: [\\n    \\\"prettier\\\", // 추가\\n    \\\"react\\\",\\n    \\\"react-hooks\\\",\\n    \\\"@typescript-eslint\\\",\\n  ],\\n  rules: {\\n    \\\"react/react-in-jsx-scope\\\": \\\"off\\\",\\n    \\\"react-hooks/rules-of-hooks\\\": \\\"error\\\",\\n    \\\"react-hooks/exhaustive-deps\\\": \\\"warn\\\",\\n    \\\"prettier/prettier\\\": \\\"error\\\", // 추가\\n  },\\n}\\n```\\n\",\"n\":0.046}}},{\"i\":11,\"$\":{\"0\":{\"v\":\"CRA - TS & ESLint & prettier 환경 설정 (2)\",\"n\":0.316},\"2\":{\"v\":\"\\n추가적으로 설정하면 좋은 내용을 덧붙인다.\\n\\n## 저장 시 자동 포매팅\\n\\n최상위 디렉토리에서 `.vscode/settings.json`를 만들고 다음과 같이 입력한다.\\n\\n````json\\n// .vscode/settings.json\\n{\\n  ...\\n  \\\"eslint.validate\\\": [\\n    \\\"javascript\\\",\\n    \\\"javascriptreact\\\",\\n    \\\"typescript\\\",\\n    \\\"typescriptreact\\\"\\n  ],\\n  \\\"editor.codeActionsOnSave\\\": {\\n    \\\"source.fixAll.eslint\\\": true,\\n  },\\n}\\n\\n## 린트 관련 명령어 추가\\n`package.json`파일에 아래의 script를 추가한다.\\n```json\\n// package.json\\n  ...\\n  \\\"scripts\\\": {\\n    ...\\n    \\\"lint\\\": \\\"eslint \\\\\\\"src/**/*.{js,jsx,ts,tsx,json}\\\\\\\"\\\",\\n    \\\"lint:fix\\\": \\\"eslint --fix \\\\\\\"src/**/*.{js,jsx,ts,tsx,json}\\\\\\\"\\\"\\n  },\\n````\\n\\n### 문제점 찾기\\n\\n```bash\\nyarn lint\\n```\\n\\n### 문제점 수정\\n\\n```bash\\nyarn lint:fix # 자동으로 문제있는 부분들을 수정한다.\\n```\\n\\n## Extension 설치 권유\\n\\n팀원에게 eslint, prettier 익스텐션을 설치하라고 권유할 수 있다.\\\\\\n프로젝트 환경을 공유할 때 유용하다.\\\\\\n최상위 디렉토리에서 `.vscode/extensions.json`를 만들고 다음과 같이 입력한다.\\n\\n```json\\n// .vscode/extensions.json\\n{\\n  \\\"recommendations\\\": [\\\"dbaeumer.vscode-eslint\\\", \\\"esbenp.prettier-vscode\\\"]\\n}\\n```\\n\\n> 더 추가하고 싶다면 배열 안에 Extension Identifier를 넣어주면 된다.\\n\\n## pre-commit 시점 검증로직 추가\\n\\n커밋 전 ESLint와 타입스크립트 검증 로직을 넣어보자.\\n\\n### 모듈 설치\\n\\n```bash\\nyarn add -D husky lint-staged npm-run-all\\n```\\n\\n> `husky`: Git Hooks를 다루기 위해 사용\\\\\\n> `lint-staged`: 커밋될 파일만 Lint검사하기 위해 사용\\\\\\n> `npm-run-all`: 스크립트 병렬실행\\n\\n### 스크립트 작성 & husky init\\n\\n`prepare`라는 스크립트를 만들어주고 실행한다.\\n\\n> prepare 스크립트를 설정해 놓으면 yarn install시 **자동**으로 실행된다.\\n\\n```bash\\nnpm set-script prepare \\\"husky install\\\"\\nnpm run prepare # .husky 폴더 생성됨\\n```\\n\\n### pacakage.json 스크립트 작성\\n\\n```json\\n// pacakage.json\\n  \\\"scripts\\\": {\\n    ...\\n    \\\"lint:fix\\\": \\\"eslint --fix \\\\\\\"src/**/*.{js,jsx,ts,tsx,json}\\\\\\\"\\\",\\n    \\\"lint-staged\\\": \\\"lint-staged\\\",\\n    \\\"check-types\\\": \\\"tsc --project tsconfig.json --pretty --noEmit\\\",\\n    \\\"validate\\\": \\\"npm-run-all --parallel check-types && lint-staged\\\"\\n  },\\n  \\\"lint-staged\\\": {\\n    \\\"*.{js,jsx,ts,tsx}\\\": \\\"yarn run lint:fix\\\"\\n  }\\n```\\n\\n### pre-commit 훅 작성\\n\\n```bash\\nnpx husky add .husky/pre-commit 'yarn validate'\\n```\\n\\n이제 커밋 시점에 설정한 스크립트를 실행한다.\\n\\n> 단점으로 pre-commit을 사용하게 되면 커밋 속도가 느려진다.\\n\",\"n\":0.07}}},{\"i\":12,\"$\":{\"0\":{\"v\":\"[Typescript] String Literal 관련하여\",\"n\":0.5},\"2\":{\"v\":\"\\n## String Literal Type이란\\n\\n`string`타입이면서도 변수에 확정된 값을 지닌 타입이다. `string`타입 보다 `narrow`한 타입이다.\\n\\n## String Literal Type인지 확인 방법\\n\\n```ts\\nvar xxx = \\\"xxx\\\" // var xxx: string\\nlet yyy = \\\"yyy\\\" // let yyy: string\\nconst zzz = \\\"zzz\\\" // const zzz: \\\"zzz\\\"\\n```\\n\\n`vscode`와 같은 IDE에서 해당 변수에 마우스를 가져다대면 타입이 유추된다.\\n타입이 값으로 나오는 경우가 `String Literal Type`이다.\\n\\n## String Literal Type은 되고 String은 안된다.\\n\\n설명에 필요한 `obj`객체이다.\\n\\n```ts\\nconst obj = {\\n  foo: \\\"hello\\\", // string\\n  bar: 12345, // number\\n  baz: true, // boolean\\n}\\n```\\n\\n`obj[key]` 은 키값에 따라서 `string`, `number`, `boolean`, `undefined`타입이 될 수 있다.\\n여기서 `obj[key]`값이 어떤 타입인지 추론하는데 두가지 방법이 있다.\\n\\n1. 1 - 인덱스 시그니쳐(index signature)를 사용하는 방법\\n2. 2 - `key`타입을 String Literal 타입으로 설정\\n\\n1번 인덱스 시그니쳐는 default 타입을 설정하는 방식이라 보면 된다.\\\\\\nString Literal타입과 관련 되어있는 2번 케이스를 보자.\\n\\n타입스크립트는 `key`타입이 `String Literal` 타입이라면 해당 객체의 속성타입을 추론할 수 있다. key값이 변하지 않으면 해당 value의 타입도 그대로 가져올 수 있기 때문이다.\\\\\\n반면에 `string`타입은 확정된 값이 아니기 때문에 어떠한 문자든 올 수 있으므로 인덱스 시그니쳐 외 방법으로는 타입추론이 불가하다.\\n\\n> 인덱스 시그니쳐를 사용하지 않았을 경우 객체의 키값으로 String이 아닌 String Literal타입이 와야 한다.\\n\\n## String Literal Type & String 예시\\n\\n```ts\\nconst fooKey = \\\"foo\\\" // 'foo' -> string literal type\\nlet barKey = \\\"bar\\\" // string type\\n\\nconst obj = {\\n  foo: \\\"hello\\\", // string\\n  bar: 12345, // number\\n  baz: true, // boolean\\n}\\n\\nobj[fooKey] // Ok\\nobj[barkey] // Error\\n```\\n\\n위의 예제 `obj[barkey]`부분에서 에러가 났다.\\n\\n> Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ foo: string; bar: number; baz: boolean; }'.  \\n> No index signature with a parameter of type 'string' was found on type '{ foo: string; bar: number; baz: boolean; }'.ts(7053)\\n\\n해당 에러는 `key`타입이 `string`타입인데 인덱스 시그니쳐(index signature)가 없다는 것이다.\\nString Literal과 관련하여 다시 풀어말하면,\\n`barKey`는 String Literal타입이 아니고 String 타입이라는 것이다.\\n\\n`let,var`키워드로 선언한 변수는 재할당이 가능하다. 따라서 타입스크립트는 해당 값이 변할 수 있다고 판단하므로 `string`타입으로 정한다.\\n반면에 `const`타입으로 정한 값은 재할당이 불가하므로 `String Literal`타입이 된다.\\n따라서 `barKey`는 `let`키워드로 작성되었기 때문에 값이 변할 수 있다고 보고 string타입으로 추론한 것이다.\\n\\n## String Literal Type의 활용\\n\\nString Literal Type은 Union Type과 궁합이 잘 맞는다.\\n같이 사용하면 `Enum`을 대체하여 사용할 수 있다.\\n\\n```ts\\nenum Keys {\\n  FOO = \\\"foo\\\",\\n  BAR = \\\"bar\\\",\\n}\\n\\ntype Keys = \\\"foo\\\" | \\\"bar\\\" | \\\"baz\\\"\\n```\\n\",\"n\":0.054}}},{\"i\":13,\"$\":{\"0\":{\"v\":\"[Typescript] swagger API 타입 자동 생성하기\",\"n\":0.408},\"2\":{\"v\":\"\\n`swagger`에 정의된 API와 모델을 자동 추출해주는 모듈인 `swagger-typescript-api`를 이용한다.\\n\\n## swagger 정보 json으로 내려받기\\n\\nswagger 경로에 `?format=openapi`를 붙여 json으로 내려받는다.\\n\\n> ex) http://localhost:8000/swagger?format=openapi\\n\\n## swagger-typescript-api 설치\\n\\n[swagger-typescript-api](https://github.com/acacode/swagger-typescript-api)를 설치한다.\\n\\n```bash\\nyarn add -D swagger-typescript-api\\n```\\n\\n## 타입 생성\\n\\n```bash\\nnpx swagger-typescript-api -p ./swagger.json -o ./src -n myApi.ts --axios --modular\\n```\\n\\n> `-p`: swagger.json 경로\\\\\\n> `-o`: output 경로\\\\\\n> `-n`: ts파일명\\\\\\n> `--axios`: axios모듈을 사용할시 적는다. (default는 `fetch` API를 사용한다.)\\\\\\n> `--modular`: http-client, data-contracts, Api routes 파일로 모듈분리해준다.\\n\\n---\\n\\n## 의도치 않은 에러\\n\\n타입스크립트 관련하여 에러가 발생했다.\\n\\n> TypeError: host.fileExists is not a function\\n\\n### yarn why typescript\\n\\n설치된 타입스크립트 버전을 확인한다.\\n\\n```bash\\nyarn why typescript\\n=> Found \\\"typescript@4.8.3\\\"\\ninfo Reasons this module exists\\n   - \\\"swagger-typescript-api\\\" depends on it\\n   - Hoisted from \\\"swagger-typescript-api#typescript\\\"\\ninfo Disk size without dependencies: \\\"65.97MB\\\"\\ninfo Disk size with unique dependencies: \\\"65.97MB\\\"\\ninfo Disk size with transitive dependencies: \\\"65.97MB\\\"\\ninfo Number of shared dependencies: 0\\nDone in 0.46s.\\n```\\n\\n### yarn.lock\\n\\n모듈에서 의존하는 타입스크립트 버전을 확인한다.\\n\\n```\\nswagger-typescript-api@^10.0.1:\\n  version \\\"10.0.1\\\"\\n  resolved \\\"https://registry.yarnpkg.com/swagger-typescript-api/-/swagger-typescript-api-10.0.1.tgz#6e74046d3d9b8337e3ae53f735353409cf99f232\\\"\\n  integrity sha512-RXi8Vjslzi7PNttHVy0ww2TyX4eB3bYUyLmFLIJTdMSeSBgiDSDwotk/WS87mtK+20hQQxIqaZ1RZnYr7x9zQw==\\n  dependencies:\\n    ...\\n    typescript \\\"^4.7.4\\\"\\n```\\n\\n현재는 `4.8` 모듈 dependency는 `4.7` 이므로 package.json 의 `resolutions`에다가 typescript 버전을 `4.7`대로 마이너 버전을 낮춘다.\\n\\n### pacakage.json\\n\\n```json\\n   ...\\n  \\\"resolutions\\\": {\\n    \\\"typescript\\\": \\\"4.7.4\\\"\\n  }\\n\\n```\\n\\n### yarn 재설치\\n\\n```bash\\nyarn install\\n```\\n\\n## 자동 생성된 api 사용법\\n\\n```ts\\nimport { Api } from \\\"./src/Api\\\"\\nexport const client = new Api({ baseURL: \\\"http://localhost:3000\\\" })\\n\\nfunction authRequestInterceptor(config: AxiosRequestConfig) {\\n  const token = storage.getToken()\\n  if (config.headers) {\\n    if (token) {\\n      config.headers.authorization = `BEARER ${token}`\\n    }\\n    config.headers.accept = \\\"application/json\\\"\\n  }\\n  return config\\n}\\n\\n// Interceptor 설정\\nclient.instance.interceptors.request.use(authRequestInterceptor)\\nclient.instance.interceptors.request.use(\\n  config => {\\n    console.log({ config })\\n\\n    return config\\n  },\\n  function (error) {\\n    return Promise.reject(error)\\n  }\\n)\\n\\nclient.instance.interceptors.response.use(\\n  response => {\\n    return response // or response.data\\n  },\\n  error => {\\n    const message = error.response?.data?.message || error.message\\n    console.error({ message })\\n    return Promise.reject(error)\\n  }\\n)\\n\\nconst axios = client.instance\\nexport default axios\\n```\\n\",\"n\":0.064}}},{\"i\":14,\"$\":{\"0\":{\"v\":\"[HTML] div 영역 focusing 하기\",\"n\":0.447},\"2\":{\"v\":\"\\n```js\\nconst div = document.querySelector(\\\"#testDiv\\\")\\ndiv.focus() // ❌작동 안함\\n```\\n\\n```html\\n<!-- 대화형 콘텐츠 -->\\n<a>\\n<button>\\n<details>\\n<embed>\\n<iframe>\\n<label>\\n<select>\\n<textarea>\\n```\\n\\n위 표기된 태그가 아닌 나머지 태그들은 `tabindex` 속성을 추가해야 포커싱 된다.\\n\\n```html\\n<!-- -1인 경우 마우스 클릭 또는 스크립트로만 포커싱 가능 -->\\n<div tabindex=\\\"-1\\\"></div>\\n\\n<!-- 양의 정수인 경우 키보드로도 접근 가능 -->\\n<div tabindex=\\\"0\\\"></div>\\n```\\n\",\"n\":0.162}}},{\"i\":15,\"$\":{\"0\":{\"v\":\"[Javascript] 하위 태그 제외한 텍스트 정보 가져오기\",\"n\":0.378},\"2\":{\"v\":\"\\n## 문제\\n\\n웹상의 데이터를 크롤링하다가 문제가 생겼다.\\n\\n```html\\n<html>\\n  <head></head>\\n  <body>\\n    <div id=\\\"name\\\">\\n      원하는 텍스트\\n      <!-- 크롤링하고 싶은 텍스트 -->\\n      <h3 id=\\\"description\\\">필요없는 텍스트</h3>\\n      <ul>\\n        <li>리스트원</li>\\n        <li>리스트투</li>\\n      </ul>\\n    </div>\\n  </body>\\n</html>\\n```\\n\\n`원하는 텍스트`만을 크롤링하고 싶은데 Sibling 태그 정보들 까지 추출되었다.\\n\\n```js\\ndocument.querySelector(\\\"#name\\\").textContent\\n// '원하는 텍스트필요없는 텍스트리스트원리스트투'\\n\\ndocument.querySelector(\\\"#name\\\").innerText\\n// '원하는 텍스트\\\\n필요없는 텍스트\\\\n리스트원\\\\n리스트투'\\n```\\n\\n## 원인\\n\\nMDN 문서([textContent](https://developer.mozilla.org/ko/docs/Web/API/Node/textContent), [innerText](https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/innerText))에 따르면 textContent와 innerText 둘 다 하위의 텍스트까지 나타낸다고 정의되어 있다.\\n\\n해당 node들을 구분하는 정보가 필요하다.\\n\\n## 해결\\n\\n```js\\n// 유사배열이기 때문에 Array.from으로 감싸준다.\\nArray.from(document.querySelector(\\\"#name\\\").childNodes)\\n  .filter(node => node.nodeType === 3)\\n  .map(node => node.data)\\n  .join(\\\"\\\")\\n```\\n\\nnodeType으로 텍스트노드만 필터링하여 해결하였다.\\\\\\nnodeType이 3인 데이터가 해당 node의 Text정보다.\\\\\\n[nodeType MDN](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType)\\n\",\"n\":0.112}}}]}","data":[{"id":"226ce064-cb66-5f21-8a0b-a0ead9a97a8e","slug":"/blog/git/git 이전 브랜치로 되돌아가기/","title":"[Git] git 이전 브랜치로 되돌아가기","desc":"","body":"\n## 이전 브랜치로 되돌아가기\n\n```bash\ngit checkout @{-1}\n```\n\n`git checkout @{-n}` n단계 이전의 브랜치로 돌아가는 명령어다.\n\n## 더 간단하게는.\n\n```bash\ngit checkout -\n```\n\n@{-1}를 -로 축약해서 사용 가능하다.\n\n> 두 브랜치를 병행하여 작업하는 경우가 많은데 이 떄 `git checkout -`를 이용하자.\n"},{"id":"28f1b316-638f-5e2d-8840-32177675b0e6","slug":"/blog/javascript/[2022-06-15 00] import-export/","title":"[Javascript] ES6 import/export 구문 정리","desc":"ES6 import/export 구문 정리","body":"\nes6모듈 import/export 내용이다. (commonjs import/export 정리는 따로)\n\n## Default import/export vs Name import/export\n\n### Default import/export\n\nexport default는 이름이 필요없다. 따라서 import 시 원하는 변수명으로 가져오면 된다.\n\n```js\n/// personInfo.js\n\n// default export\nexport default {\n    name: '아무개',\n    age: 22,\n}\n\n...\n\n// ✔ default를 import시 변수명을 임의로 정할 수 있다.\nimport personInfo from './personInfo.js'\nconsole.log(personInfo) // { name: '아무개', age: 22 }\n\n// ✔ Import All 문법 사용 시 export default 정보는 'default'속성으로 접근할 수 있다.\nimport * as personInfo from './personInfo.js'\nconsole.log(personInfo.default) // { name: '아무개', age: 22 }\n\n// ❌ default의 속성 정보는 객체 구조 분해 할당을 통해서 가져올 수 없다. (일반 객체에서 가져오는 것과 문법이 다름)\nimport { name, age } from './personInfo.js' // Error\n```\n\n### Name import/export\n\n#### Name export\n\n```js\n/// colorInfo.js\n\n// name export 방법 1\nexport const hex = '#fff'\nexport const name = 'white'\n\n// name export 방법 2\nconst hex = '#fff'\nconst name = 'white'\n\nexport {\n    hex, // hex: '#fff', 처럼 선언 불가\n    name,\n}\n\n// ❌ 잘못된 name export 방법\nexport {\n    hex: '#fff', // ❌\n    name: 'white', // ❌\n}\n\n// export 뒷 {} 내용은 일반 객체가 아니다.\n// 변수명만 콤마로 나열할 수 있다.\n\n```\n\n#### Name import\n\n```js\n// ✔ Name import/export는 중괄호로 묶어서 가져온다.\nimport { hex, name } from \"./colorInfo.js\"\nconsole.log(hex, name) // #fff white\n\n// alias를 주어 변경된 명칭으로 할당할 수 있다.\nimport { hex as color, name } from \"./colorInfo.js\"\nconsole.log(color, name) // #fff white\n\n// ✔ Import All 문법으로 가져올 수 있다.\nimport * as colorInfo from \"./colorInfo.js\"\nconsole.log(colorInfo.hex, colorInfo.name) // #fff, white\n\n// ❌Default Export를 가져오는 방식이므로 Error\nimport moduleWithName from \"./colorInfo.js\" // The requested module './colorInfo.js' does not provide an export named 'default'\n```\n\n### Default import/export, Name import/export 혼합 예제\n\n```js\n/// mix.js\nexport const hex = '#fff'\nexport const name = 'white'\n\nexport default {\n    name: '아무개',\n    age: 22,\n}\n...\n\nimport personInfo, { hex, name } from './mix.js' // ✔ personInfo는 default, 그외 Name Export와 연결된다.\nconsole.log(personInfo.name) // 홍길동\nconsole.log(personInfo.age) // 22\nconsole.log(hex, name) // #fff white\n\n// ✔\nimport * as test from './mix.js'\nconsole.log(test.default.name) //  무개\nconsole.log(test.name) // white\n```\n"},{"id":"93571463-34ea-5ddb-941c-2faa2b8e6b51","slug":"/blog/git/[2022-09-05 01] git 원격 브랜치 삭제/","title":"[Git] git 원격 브랜치 삭제","desc":"","body":"\n## 삭제할 원격 브랜치 조회\n\n```bash\ngit branch -r\n: '\n  origin/HEAD -> origin/master\n  origin/develop\n  origin/features/add-something # 삭제 대상\n  origin/master\n'\n```\n\n## 원격 브랜치 삭제\n\n```bash\ngit push origin --delete features/add-something\n```\n\n### 기타\n\n실제 원격에 없는데 `git branch -r`에서 조회되는 경우\n\n```bash\ngit fetch -p # 로컬 캐시 Clear\n```\n"},{"id":"e637e5d9-c187-5d67-8293-f74d90fb72d3","slug":"/blog/javascript/[2022-08-29 01] findUniqueInArray/","title":"[Javascript] 배열 내 중복된 정보 추출하기","desc":"","body":"\n배열 내 중복된 요소 가져오기\n\n```js\n// target\nconst strArray = [\"q\", \"w\", \"w\", \"w\", \"e\", \"i\", \"u\", \"r\"]\n\n// 첫번째 인자값만 가져오는 indexOf를 통해 필터링하기\nconst findDuplicates = arr =>\n  arr.filter((item, index) => arr.indexOf(item) !== index)\nconst duplicatedItems = [...new Set(findDuplicates(strArray))]\n```\n"},{"id":"66b28a86-6e71-55af-8f11-b11b836c6e88","slug":"/blog/javascript/[2022-08-29 03] JSON stringify undefined 값 남기기/","title":"[Javascript] JSON stringify undefined 속성값 관련","desc":"","body":"\n```js\nconst params = {\n  a: 1,\n  b: 2,\n  c: null,\n  d: undefined,\n}\nconst result = JSON.stringify(params)\n\nconsole.log(result) // {\"a\":1,\"b\":2,\"c\":null}\n```\n\n위의 params 객체에서 stringify할 때 값이 `undefined`인 `d` 속성은 결과 값에 나오지 않는다.\n\n물론 아래와 같이 parsing하여 결과를 가져오면 같은 같은 값이 나온다.\n\n```js\nconst params = {\n  a: 1,\n  b: 2,\n  c: null,\n  d: undefined,\n}\nconst result = JSON.stringify(params)\n\nconst parsedData = JSON.parse(result)\nconsole.log(params.d) // undefined\nconsole.log(parsedData.d) // undefined\n```\n\n문제는 APi 서버에서 d 속성이 없어서 에러가 났다.\n\n해결, JSON.stringify 두번째 인자로 replacer 함수를 넣어 원하는 대로 값으로 변경하면 된다.\n\n```js\nconst replacer = (key, value) => (typeof value === \"undefined\" ? null : value) // undefined to null\nconst params = {\n  a: 1,\n  b: 2,\n  c: null,\n  d: undefined,\n}\nconst result = JSON.stringify(params, replacer)\n\nconsole.log(result) // {\"a\":1,\"b\":2,\"c\":null,\"d\":null}\n```\n"},{"id":"0158b780-9d80-5e36-936d-6597fb98a350","slug":"/blog/javascript/[2022-08-29 00] IIFE/","title":"[Javascript] IIFE란","desc":"","body":"\n`Immediately Invoked Function Expressions`의 약어로 즉시실행 함수를 뜻한다.\n\n```js\nfunction () {\n    // 내용\n}\n```\n\n> 선언한 함수에\n\n```js\n;(function () {\n  // 내용\n})() // invoke\n```\n\n> 소괄호로 묶어 바로 실행하는 표현식이다.\n\nes6문법이 나오기 전에는 `var`키워드를 통해 변수를 선언했는데\\\nvar 스코프가 `Function Scope`였으므로 전역 영역을 오염시키기 쉬웠다.\\\n전역 영역 오염을 방지하고 캡슐화하기 위해 많이 사용했다.\n\n지금은 es6문법 `Block Scope`인 `let` `const` 키워드가 나와서\\\nIIFE문법은 잘 사용하지 않는 듯 하다.\n\nJquery 라이브러리 예시\n\n```js\n/// https://code.jquery.com/jquery-3.6.1.js\n;(function (global, factory) {\n  \"use strict\"\n\n  if (typeof module === \"object\" && typeof module.exports === \"object\") {\n    module.exports = global.document\n      ? factory(global, true)\n      : function (w) {\n          if (!w.document) {\n            throw new Error(\"jQuery requires a window with a document\")\n          }\n          return factory(w)\n        }\n  } else {\n    factory(global)\n  }\n\n  // Pass this if window is not defined yet\n})(\n  typeof window !== \"undefined\" ? window : this,\n  function (window, noGlobal) {}\n)\n```\n"},{"id":"28f40c1a-dd21-5017-acb6-b2de9cbd1bd2","slug":"/blog/javascript/[2022-09-02 01] Array.slice.call 그리고 Array.from/","title":"[Javascript] Array.slice.call 그리고 Array.from","desc":"","body":"\n개발하다 이상한 문법을 발견했다.\n\n```js\nfunction testFunction () {\n    console.log(arguments) // Array Like Object\n    console.log([].slice.call(arguments)) // [1, 2, 3, 4, 5]\n    console.log(Array.prototype.slice.call(arguments)) // [1, 2, 3, 4, 5]\n\n    ...\n}\n\ntestFunction(1,2,3,4,5) // [1, 2, 3, 4, 5]\n```\n\nslice.call을 사용하더라\n\n## 이유\n\n`arguments`를 배열처럼 다루기 위해 Array.slice()를 이용한 것이다.\\\n`arguments`는 유사배열이며 실제 배열이 아니라\\\n`forEach()`, `map()`, `reduce()`와 같은 Array 인스턴스함수를 사용하지 못한다.\n\n하지만 arguments 는 유사배열이므로 `[].fn.call(arguments, ...)`를 이용해서 함수를 호출할 수 있다.\n\n여기서 Array.slice()는 새로운 배열 객체를 반환해주므로 반환된 객체를 이용하려고 사용한 것이다. ([MDN Array.slice()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/slice))\n\n## ES6\n\nES6문법이 생기고 나서는 `slice.call()`를 이용할 필요가 없어졌다.\\\n유사배열을 새로운 객체로 반환해주는 `Array.from()`함수가 생겼다. ([MDN Array.from()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from))\\\n또는 스프레드 연산자(...)으로도 대체 가능하다. ([MDN ...](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Spread_syntax))\n\n```js\nfunction testFunction() {\n  console.log(arguments) // Array Like Object\n  console.log(Array.from(arguments)) // [1, 2, 3, 4, 5]\n  console.log([...arguments]) // [1, 2, 3, 4, 5]\n}\n```\n"},{"id":"3d445b09-aabc-545d-9f69-4b8d641241fb","slug":"/blog/javascript/[2022-09-02 01] el 속성 출력/","title":"[Javascript] DOM Element 속성 출력하기","desc":"","body":"\n## 문제\n\ndocument.querySelector('div')로 어떤 속성이 있는지 파악하기 위해\\\n`Object.keys()`를 이용해 출력을 해보았다.\n\n```js\nconst $div = document.querySelector(\"div\")\nObject.keys($div) // []\n```\n\n$div 객체가 값이 있는데도 style이나 dataset 속성들이 출력되지 않았다.\n\n## 원인\n\n[MDN Object.keys()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)에 의하면\\\n주어진 객체 자신의(프로토타입 제외) 열거가능한 속성만 배열로 반환한다고 나와있다.\n\n정리하자면\n\n```js\nconst testObj = {\n  a: 1,\n  b: 2,\n}\nObject.defineProperty(testObj, \"c\", {\n  value: 3,\n  enumerable: true,\n})\nObject.defineProperty(testObj, \"d\", {\n  value: 4,\n  enumerable: false,\n}) // d 속성은 non enumerable 이므로 출력되지 않음\n\nconsole.log(Object.keys(testObj)) // ['a', 'b', 'c']\n\nfunction testFunction() {\n  this.a = 1\n  this.b = 2\n}\ntestFunction.prototype.c = 3 // 프로토타입의 속성이므로 출력되지 않음\nconsole.log(Object.keys(new testFunction())) // ['a', 'b']\n```\n\n## 해결\n\n위 내용들로 볼 때 두가지 문제가 있다.\n\n문제\n\n- 1.Object.keys는 열거가능한 속성만 가져온다.\n- 2.프로토타입 정보는 가져오지 않는다.\n\n해결\n\n- 1.열거 가능한 속성도 출력하는 [Object.getOwnPropertyNames()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)를 사용한다.\n- 2.[Object.getPrototypeOf()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)함수를 이용한다.\n\n```js\nfunction getAllPropertyKeys(el) {\n  let obj = []\n  let target = el\n  while (true) {\n    obj = [...obj, ...Object.getOwnPropertyNames(target)]\n\n    const proto = Object.getPrototypeOf(target)\n    if (!proto) break\n    target = proto\n  }\n\n  return obj\n}\n\nconst $div = document.querySelector(\"div\")\nconsole.log(getAllPropertyKeys($div))\n```\n"},{"id":"ffad8f97-8e69-572b-972d-741b58f0db96","slug":"/blog/javascript/[2022-09-05 01] 속성 존재 여부 판단/","title":"[Javascript] 속성 존재 여부 판단","desc":"","body":"\nJavascript 객체에 `age`속성이 존재하는지 판단하는 방법\n\n### 방법 1. obj.age !== undefined\n\n`age`값이 undefined일 수 없다는 가정하에 사용 가능하다.\n\n```js\nfunction existsAgeProp(obj) {\n  return obj.age !== undefined\n}\n\nconst person = { name: \"김\" }\nconsole.log(existsAgeProp(person)) // false\n\n///////////////////////\n\n// age값이 undefined일 경우\nconst person2 = { name: \"김\", age: undefined }\nconsole.log(existsAgeProp(person2)) // false, ❌ age속성이 있는데 결과는 없다고 나온다.\n```\n\n### 방법 2. obj.hasOwnProperty('age')\n\nObject.prototype.hasOwnProperty() 함수를 사용한다.\\\n메서드 명에 `Own`이 들어간 것과 같이 프로토타입 속성들까지 체크하지 않는다.\n\n```js\nfunction existsAgeProp(obj) {\n  return obj.hasOwnProperty(\"age\")\n}\n\nconst person = { name: \"김\" }\nconsole.log(existsAgeProp(person)) // false\n\n// age값이 undefined인 경우\nconst person2 = { name: \"김\", age: undefined }\nconsole.log(existsAgeProp(person2)) // true\n\n///////////////////////\n\nconst person3 = {\n  name: \"김\",\n  __proto__: {\n    age: 16,\n  },\n}\nconsole.log(existsAgeProp(person3)) // false, 프로토타입 속성은 체크하지 않는다.\n```\n\n### 방법 3. 'age' in obj\n\n해당 객체와 프로토타입 체인 내 모든 속성들까지 모두 검증하려면 `in` 연산자를 사용한다.\n\n```js\nfunction existsAgeProp(obj) {\n  return \"age\" in obj\n}\n\nconst person = { name: \"김\" }\nconsole.log(existsAgeProp(person)) // false\n\n// age값이 undefined인 경우\nconst person2 = { name: \"김\", age: undefined }\nconsole.log(existsAgeProp(person2)) // true\n\nconst person3 = {\n  name: \"김\",\n  __proto__: {\n    age: 16,\n  },\n}\nconsole.log(existsAgeProp(person3)) // true\n```\n"},{"id":"2b969743-90d5-5a5a-b814-f9d4a6630d87","slug":"/blog/javascript/[2022-09-05 02] moment UTC/","title":"[Javascript] UTC 관련 날짜 정리 (with moment.js)","desc":"","body":"\n날짜 관련해서 헷갈리는 부분을 정리해보았다.\n\nGMT란 `Greenwich Mean Time`의 약어로 그리니치 평균시를 뜻한다.\\\n영군 런던에 소재한 그리니치 천문대를 기점으로 정했다. GMT(+0)\n\n> GMT+0은 Z로 표기한다. (Zulu Time)\\\n> 한국은 `GMT+9` 이다.\n\nUTC(`Universal Time Coordinated`)는 협정 세계시를 뜻한다.\\\nUTC는 GMT에 기반하므로 GMT라 불리기도 하는데\\\n기술적인 표기로 `UTC`가 맞다.\n\n> 실제 UTC와 GMT의 차이는 밀리초정도만 차이난다.\\\n> 한국은 `UTC+9` 이다. (GMT와 동일)\n\n## 애매모호한 부분\n\n```js\nconsole.log(new Date(\"2022-09-05\").toISOString()) // 2022-09-05T00:00:00.000Z // UTC+0\nconsole.log(new Date(\"2022/09/05\").toISOString()) // 2022-09-04T15:00:00.000Z // localTime\n```\n\n파싱할 문자열에 UTC 정보가 없을 경우, `-`으로 구분하냐 `/`으로 구분하냐에 따라 시간대 정보가 다르게 출력된다.\n\nISO 표준은 UTC 관련정보가 없으면(Z 또는 +00:00)\\\n`local time`으로 가정한다고 나와있다. ([ISO_8601](<https://en.wikipedia.org/wiki/ISO_8601#Local_time_(unqualified)>))\n\n하지만 ES5에선 `UTC+0`로 가정한다.\n\n하이픈(`-`)으로 구분된 문자는 되도록 ECMA 표준을 따르지만 그 외에는 ISO 표준을 따르고 있다.\n\n이런 부분이 애매모호해서 그런지\\\n`moment.js`에서는 `-`이든 `/`이든 ISO 기준으로 출력한다. (UTC 정보가 없을 경우 Local Time 기준으로)\n\n```js\nconsole.log(moment(\"2022-09-05\").format()) // 2022-09-05T00:00:00+09:00\nconsole.log(moment(\"2022/09/05\").format()) // 2022-09-05T00:00:00+09:00\n```\n\n다만 `UTC+0` 기준으로 표기하고 싶을 때엔 `utc`를 활용한다.\n\n```js\nconsole.log(moment.utc(\"2022-09-05\").format()) // 2022-09-05T00:00:00Z\n```\n\n`local time`으로 표기된 정보를 `utc` 기준으로 보고 싶을 경우에는\n\n```js\nconsole.log(moment(\"2022-09-05\").utc().format()) // 2022-09-04T15:00:00Z\n```\n"},{"id":"b113d23f-df70-55c3-9a68-4c0cb80b5dbd","slug":"/blog/others/cra 환경설정-1/","title":"CRA - TS & ESLint & prettier 환경 설정 (1)","desc":"","body":"\nCRA 프로젝트에 eslint와 prettier를 셋업해보자.\n\n## 1. CRA typescript 템플릿 설치\n\n우선 Create React App 타입스크립트 템플릿으로 프로젝트를 생성한다.\n\n```bash\nyarn create react-app my-app --template typescript\ncd my-app\ncode . # vs-code 실행\n```\n\n## 2. ESLint 사전 준비\n\n### eslint 모듈 설치\n\n```bash\nyarn add -D eslint\n```\n\n### ESLint Extension 설치\n\nvscode extensions에서 `ESLint`를 설치한다.\n\n> ESLint환경에선 필수다.\n\n## 3. eslintrc 파일 생성\n\nESLint를 사용하려면 프로젝트 최상위 폴더에 eslintrc 파일이 있어야 한다.\\\n최상위 폴더에 가서 터미널로 `npm init @eslint/config`를 입력한다.\n\n```bash\nnpm init @eslint/config\n\nHow would you like to use ESLint? ...\n> To check syntax and find problems\n\nWhat type of modules does your project use? ...\n> JavaScript modules (import/export)\n\nWhich framework does your project use? ...\n> React\n\nDoes your project use TypeScript?\n> Yes\n\nWhere does your code run? ...  (Press <space> to select, <a> to toggle all, <i> to invert selection)\n√ Browser\n√ Node\n\nWhat format do you want your config file to be in? ...\nJavaScript\n\neslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest\nWould you like to install them now with npm?\nYes\n```\n\nReact와 Typescript를 사용한다고 설정하면 관련 plugin과 parser가 받아진다.\n\n> `@typescript-eslint/parser`: 타입스크립트를 linting할 수 있도록 해주는 ESLint 파서\\\n> `@typescript-eslint/eslint-plugin`: 타입스크립트 관련 linting 규칙\\\n> `eslint-plugin-react`: react 관련 linting 규칙\n\n아래는 자동 생성된 `.eslintrc.js` 내용이다.\n\n```js\n// .eslintrc.js\nmodule.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n    node: true,\n  },\n  extends: [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"plugin:@typescript-eslint/recommended\",\n  ],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    ecmaFeatures: {\n      jsx: true,\n    },\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  plugins: [\"react\", \"@typescript-eslint\"],\n  rules: {},\n}\n```\n\n## 4. React Hooks API 관련 플러그인 추가\n\n추가로 React 16.8버전에 추가된 Hooks API를 사용한다면 별도의 플러그인을 추가로 받는다.\n\n```bash\nyarn add -D eslint-plugin-react-hooks\n```\n\n### .eslintrc.js 수정\n\n```js\nmodule.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n    node: true,\n  },\n  extends: [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"plugin:@typescript-eslint/recommended\",\n  ],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    ecmaFeatures: {\n      jsx: true,\n    },\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  plugins: [\n    \"react\",\n    \"react-hooks\", // 추가\n    \"@typescript-eslint\",\n  ],\n  rules: {\n    \"react/react-in-jsx-scope\": \"off\", // 리액트 17버전 이상은 해당 룰이 의미없으므로 off\n    \"react-hooks/rules-of-hooks\": \"error\", // 추가\n    \"react-hooks/exhaustive-deps\": \"warn\", // 추가\n  },\n}\n```\n\n## 5. prettier\n\n`prettier`은 소스 내 코드포맷팅을 정해주는 모듈이다.\\\nprettier은 소스 실행과 상관 없이 가이드만 해주는 역할이기 때문에 ESLint와 연동하여 코드포맷팅을 강제하도록 한다.\n\n```bash\nyarn add -D prettier eslint-plugin-prettier eslint-config-prettier\n```\n\n`prettier`: prettier 모듈\\\n `eslint-plugin-prettier`: prettier 관련 linting 규칙\\\n `eslint-config-prettier`: 코드포맷팅 관련 ESLint 룰을 모두 비활성화시킨다. **중요** (충돌방지역할)\n\n### prettier Extension 설치\n\nvscode extensions에서 `Prettier - Code formatter`를 설치한다.\n\n> editor 상에서 밑줄로 prettier 관련 정보를 표시주거나 포맷팅을 도와준다.\n\n### prettier 설정\n\nprettier를 사용하려면 프로젝트 최상위 폴더에 prettierrc 파일이 있어야 한다.\\\n`prettierrc.json` 를 만들고 아래의 내용을 입력한다.\n\n```json\n{\n  \"useTabs\": false,\n  \"tabWidth\": 2,\n  \"singleQuote\": true,\n  \"printWidth\": 120,\n  \"trailingComma\": \"es5\"\n}\n```\n\n많이 사용하는 기본 옵션이고, 그 외 추가적인 옵션은 [docs](https://prettier.io/docs/en/options.html)를 참고하여 작성한다.\n\n> ESLint에서도 포맷팅 관련 설정을 할 수 있는데 prettier와 연동한다면 사용하지 않는 것이 좋다.\\\n> vscode에서 받은 `prettier Extension`은 prettierrc 설정 내용만 보고 포맷팅을 지원해주므로, 소스를 실행하면 에러가 나는데 에디터에서는 에러가 안나는 현상이 발생한다.\n\n### .eslintrc.js 수정\n\n```js\nmodule.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n    node: true,\n  },\n  extends: [\n    \"eslint:recommended\",\n    \"plugin:react/recommended\",\n    \"plugin:prettier/recommended\", // 추가\n    \"plugin:@typescript-eslint/recommended\",\n  ],\n  parser: \"@typescript-eslint/parser\",\n  parserOptions: {\n    ecmaFeatures: {\n      jsx: true,\n    },\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  plugins: [\n    \"prettier\", // 추가\n    \"react\",\n    \"react-hooks\",\n    \"@typescript-eslint\",\n  ],\n  rules: {\n    \"react/react-in-jsx-scope\": \"off\",\n    \"react-hooks/rules-of-hooks\": \"error\",\n    \"react-hooks/exhaustive-deps\": \"warn\",\n    \"prettier/prettier\": \"error\", // 추가\n  },\n}\n```\n"},{"id":"47c0ad8c-da87-50af-86a2-b1378ba868d8","slug":"/blog/others/cra 환경설정-2/","title":"CRA - TS & ESLint & prettier 환경 설정 (2)","desc":"","body":"\n추가적으로 설정하면 좋은 내용을 덧붙인다.\n\n## 저장 시 자동 포매팅\n\n최상위 디렉토리에서 `.vscode/settings.json`를 만들고 다음과 같이 입력한다.\n\n````json\n// .vscode/settings.json\n{\n  ...\n  \"eslint.validate\": [\n    \"javascript\",\n    \"javascriptreact\",\n    \"typescript\",\n    \"typescriptreact\"\n  ],\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true,\n  },\n}\n\n## 린트 관련 명령어 추가\n`package.json`파일에 아래의 script를 추가한다.\n```json\n// package.json\n  ...\n  \"scripts\": {\n    ...\n    \"lint\": \"eslint \\\"src/**/*.{js,jsx,ts,tsx,json}\\\"\",\n    \"lint:fix\": \"eslint --fix \\\"src/**/*.{js,jsx,ts,tsx,json}\\\"\"\n  },\n````\n\n### 문제점 찾기\n\n```bash\nyarn lint\n```\n\n### 문제점 수정\n\n```bash\nyarn lint:fix # 자동으로 문제있는 부분들을 수정한다.\n```\n\n## Extension 설치 권유\n\n팀원에게 eslint, prettier 익스텐션을 설치하라고 권유할 수 있다.\\\n프로젝트 환경을 공유할 때 유용하다.\\\n최상위 디렉토리에서 `.vscode/extensions.json`를 만들고 다음과 같이 입력한다.\n\n```json\n// .vscode/extensions.json\n{\n  \"recommendations\": [\"dbaeumer.vscode-eslint\", \"esbenp.prettier-vscode\"]\n}\n```\n\n> 더 추가하고 싶다면 배열 안에 Extension Identifier를 넣어주면 된다.\n\n## pre-commit 시점 검증로직 추가\n\n커밋 전 ESLint와 타입스크립트 검증 로직을 넣어보자.\n\n### 모듈 설치\n\n```bash\nyarn add -D husky lint-staged npm-run-all\n```\n\n> `husky`: Git Hooks를 다루기 위해 사용\\\n> `lint-staged`: 커밋될 파일만 Lint검사하기 위해 사용\\\n> `npm-run-all`: 스크립트 병렬실행\n\n### 스크립트 작성 & husky init\n\n`prepare`라는 스크립트를 만들어주고 실행한다.\n\n> prepare 스크립트를 설정해 놓으면 yarn install시 **자동**으로 실행된다.\n\n```bash\nnpm set-script prepare \"husky install\"\nnpm run prepare # .husky 폴더 생성됨\n```\n\n### pacakage.json 스크립트 작성\n\n```json\n// pacakage.json\n  \"scripts\": {\n    ...\n    \"lint:fix\": \"eslint --fix \\\"src/**/*.{js,jsx,ts,tsx,json}\\\"\",\n    \"lint-staged\": \"lint-staged\",\n    \"check-types\": \"tsc --project tsconfig.json --pretty --noEmit\",\n    \"validate\": \"npm-run-all --parallel check-types && lint-staged\"\n  },\n  \"lint-staged\": {\n    \"*.{js,jsx,ts,tsx}\": \"yarn run lint:fix\"\n  }\n```\n\n### pre-commit 훅 작성\n\n```bash\nnpx husky add .husky/pre-commit 'yarn validate'\n```\n\n이제 커밋 시점에 설정한 스크립트를 실행한다.\n\n> 단점으로 pre-commit을 사용하게 되면 커밋 속도가 느려진다.\n"},{"id":"fc557eb1-20cf-5b08-8690-0d1f88927125","slug":"/blog/typescript/String Literal/","title":"[Typescript] String Literal 관련하여","desc":"","body":"\n## String Literal Type이란\n\n`string`타입이면서도 변수에 확정된 값을 지닌 타입이다. `string`타입 보다 `narrow`한 타입이다.\n\n## String Literal Type인지 확인 방법\n\n```ts\nvar xxx = \"xxx\" // var xxx: string\nlet yyy = \"yyy\" // let yyy: string\nconst zzz = \"zzz\" // const zzz: \"zzz\"\n```\n\n`vscode`와 같은 IDE에서 해당 변수에 마우스를 가져다대면 타입이 유추된다.\n타입이 값으로 나오는 경우가 `String Literal Type`이다.\n\n## String Literal Type은 되고 String은 안된다.\n\n설명에 필요한 `obj`객체이다.\n\n```ts\nconst obj = {\n  foo: \"hello\", // string\n  bar: 12345, // number\n  baz: true, // boolean\n}\n```\n\n`obj[key]` 은 키값에 따라서 `string`, `number`, `boolean`, `undefined`타입이 될 수 있다.\n여기서 `obj[key]`값이 어떤 타입인지 추론하는데 두가지 방법이 있다.\n\n1. 1 - 인덱스 시그니쳐(index signature)를 사용하는 방법\n2. 2 - `key`타입을 String Literal 타입으로 설정\n\n1번 인덱스 시그니쳐는 default 타입을 설정하는 방식이라 보면 된다.\\\nString Literal타입과 관련 되어있는 2번 케이스를 보자.\n\n타입스크립트는 `key`타입이 `String Literal` 타입이라면 해당 객체의 속성타입을 추론할 수 있다. key값이 변하지 않으면 해당 value의 타입도 그대로 가져올 수 있기 때문이다.\\\n반면에 `string`타입은 확정된 값이 아니기 때문에 어떠한 문자든 올 수 있으므로 인덱스 시그니쳐 외 방법으로는 타입추론이 불가하다.\n\n> 인덱스 시그니쳐를 사용하지 않았을 경우 객체의 키값으로 String이 아닌 String Literal타입이 와야 한다.\n\n## String Literal Type & String 예시\n\n```ts\nconst fooKey = \"foo\" // 'foo' -> string literal type\nlet barKey = \"bar\" // string type\n\nconst obj = {\n  foo: \"hello\", // string\n  bar: 12345, // number\n  baz: true, // boolean\n}\n\nobj[fooKey] // Ok\nobj[barkey] // Error\n```\n\n위의 예제 `obj[barkey]`부분에서 에러가 났다.\n\n> Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ foo: string; bar: number; baz: boolean; }'.  \n> No index signature with a parameter of type 'string' was found on type '{ foo: string; bar: number; baz: boolean; }'.ts(7053)\n\n해당 에러는 `key`타입이 `string`타입인데 인덱스 시그니쳐(index signature)가 없다는 것이다.\nString Literal과 관련하여 다시 풀어말하면,\n`barKey`는 String Literal타입이 아니고 String 타입이라는 것이다.\n\n`let,var`키워드로 선언한 변수는 재할당이 가능하다. 따라서 타입스크립트는 해당 값이 변할 수 있다고 판단하므로 `string`타입으로 정한다.\n반면에 `const`타입으로 정한 값은 재할당이 불가하므로 `String Literal`타입이 된다.\n따라서 `barKey`는 `let`키워드로 작성되었기 때문에 값이 변할 수 있다고 보고 string타입으로 추론한 것이다.\n\n## String Literal Type의 활용\n\nString Literal Type은 Union Type과 궁합이 잘 맞는다.\n같이 사용하면 `Enum`을 대체하여 사용할 수 있다.\n\n```ts\nenum Keys {\n  FOO = \"foo\",\n  BAR = \"bar\",\n}\n\ntype Keys = \"foo\" | \"bar\" | \"baz\"\n```\n"},{"id":"298566f1-a129-579b-87bb-cc5e90b96522","slug":"/blog/typescript/swagger API 타입 자동 생성/","title":"[Typescript] swagger API 타입 자동 생성하기","desc":"","body":"\n`swagger`에 정의된 API와 모델을 자동 추출해주는 모듈인 `swagger-typescript-api`를 이용한다.\n\n## swagger 정보 json으로 내려받기\n\nswagger 경로에 `?format=openapi`를 붙여 json으로 내려받는다.\n\n> ex) http://localhost:8000/swagger?format=openapi\n\n## swagger-typescript-api 설치\n\n[swagger-typescript-api](https://github.com/acacode/swagger-typescript-api)를 설치한다.\n\n```bash\nyarn add -D swagger-typescript-api\n```\n\n## 타입 생성\n\n```bash\nnpx swagger-typescript-api -p ./swagger.json -o ./src -n myApi.ts --axios --modular\n```\n\n> `-p`: swagger.json 경로\\\n> `-o`: output 경로\\\n> `-n`: ts파일명\\\n> `--axios`: axios모듈을 사용할시 적는다. (default는 `fetch` API를 사용한다.)\\\n> `--modular`: http-client, data-contracts, Api routes 파일로 모듈분리해준다.\n\n---\n\n## 의도치 않은 에러\n\n타입스크립트 관련하여 에러가 발생했다.\n\n> TypeError: host.fileExists is not a function\n\n### yarn why typescript\n\n설치된 타입스크립트 버전을 확인한다.\n\n```bash\nyarn why typescript\n=> Found \"typescript@4.8.3\"\ninfo Reasons this module exists\n   - \"swagger-typescript-api\" depends on it\n   - Hoisted from \"swagger-typescript-api#typescript\"\ninfo Disk size without dependencies: \"65.97MB\"\ninfo Disk size with unique dependencies: \"65.97MB\"\ninfo Disk size with transitive dependencies: \"65.97MB\"\ninfo Number of shared dependencies: 0\nDone in 0.46s.\n```\n\n### yarn.lock\n\n모듈에서 의존하는 타입스크립트 버전을 확인한다.\n\n```\nswagger-typescript-api@^10.0.1:\n  version \"10.0.1\"\n  resolved \"https://registry.yarnpkg.com/swagger-typescript-api/-/swagger-typescript-api-10.0.1.tgz#6e74046d3d9b8337e3ae53f735353409cf99f232\"\n  integrity sha512-RXi8Vjslzi7PNttHVy0ww2TyX4eB3bYUyLmFLIJTdMSeSBgiDSDwotk/WS87mtK+20hQQxIqaZ1RZnYr7x9zQw==\n  dependencies:\n    ...\n    typescript \"^4.7.4\"\n```\n\n현재는 `4.8` 모듈 dependency는 `4.7` 이므로 package.json 의 `resolutions`에다가 typescript 버전을 `4.7`대로 마이너 버전을 낮춘다.\n\n### pacakage.json\n\n```json\n   ...\n  \"resolutions\": {\n    \"typescript\": \"4.7.4\"\n  }\n\n```\n\n### yarn 재설치\n\n```bash\nyarn install\n```\n\n## 자동 생성된 api 사용법\n\n```ts\nimport { Api } from \"./src/Api\"\nexport const client = new Api({ baseURL: \"http://localhost:3000\" })\n\nfunction authRequestInterceptor(config: AxiosRequestConfig) {\n  const token = storage.getToken()\n  if (config.headers) {\n    if (token) {\n      config.headers.authorization = `BEARER ${token}`\n    }\n    config.headers.accept = \"application/json\"\n  }\n  return config\n}\n\n// Interceptor 설정\nclient.instance.interceptors.request.use(authRequestInterceptor)\nclient.instance.interceptors.request.use(\n  config => {\n    console.log({ config })\n\n    return config\n  },\n  function (error) {\n    return Promise.reject(error)\n  }\n)\n\nclient.instance.interceptors.response.use(\n  response => {\n    return response // or response.data\n  },\n  error => {\n    const message = error.response?.data?.message || error.message\n    console.error({ message })\n    return Promise.reject(error)\n  }\n)\n\nconst axios = client.instance\nexport default axios\n```\n"},{"id":"f2c3a7d8-3939-5737-85c5-d227a94f3a10","slug":"/blog/javascript/[2022-08-29 02] div 영역 focusing 하기/","title":"[HTML] div 영역 focusing 하기","desc":"","body":"\n```js\nconst div = document.querySelector(\"#testDiv\")\ndiv.focus() // ❌작동 안함\n```\n\n```html\n<!-- 대화형 콘텐츠 -->\n<a>\n<button>\n<details>\n<embed>\n<iframe>\n<label>\n<select>\n<textarea>\n```\n\n위 표기된 태그가 아닌 나머지 태그들은 `tabindex` 속성을 추가해야 포커싱 된다.\n\n```html\n<!-- -1인 경우 마우스 클릭 또는 스크립트로만 포커싱 가능 -->\n<div tabindex=\"-1\"></div>\n\n<!-- 양의 정수인 경우 키보드로도 접근 가능 -->\n<div tabindex=\"0\"></div>\n```\n"},{"id":"69a9d6fe-efd5-5621-a909-d7f39bb23758","slug":"/blog/javascript/[2022-09-01 01] TextNode 추출/","title":"[Javascript] 하위 태그 제외한 텍스트 정보 가져오기","desc":"","body":"\n## 문제\n\n웹상의 데이터를 크롤링하다가 문제가 생겼다.\n\n```html\n<html>\n  <head></head>\n  <body>\n    <div id=\"name\">\n      원하는 텍스트\n      <!-- 크롤링하고 싶은 텍스트 -->\n      <h3 id=\"description\">필요없는 텍스트</h3>\n      <ul>\n        <li>리스트원</li>\n        <li>리스트투</li>\n      </ul>\n    </div>\n  </body>\n</html>\n```\n\n`원하는 텍스트`만을 크롤링하고 싶은데 Sibling 태그 정보들 까지 추출되었다.\n\n```js\ndocument.querySelector(\"#name\").textContent\n// '원하는 텍스트필요없는 텍스트리스트원리스트투'\n\ndocument.querySelector(\"#name\").innerText\n// '원하는 텍스트\\n필요없는 텍스트\\n리스트원\\n리스트투'\n```\n\n## 원인\n\nMDN 문서([textContent](https://developer.mozilla.org/ko/docs/Web/API/Node/textContent), [innerText](https://developer.mozilla.org/ko/docs/Web/API/HTMLElement/innerText))에 따르면 textContent와 innerText 둘 다 하위의 텍스트까지 나타낸다고 정의되어 있다.\n\n해당 node들을 구분하는 정보가 필요하다.\n\n## 해결\n\n```js\n// 유사배열이기 때문에 Array.from으로 감싸준다.\nArray.from(document.querySelector(\"#name\").childNodes)\n  .filter(node => node.nodeType === 3)\n  .map(node => node.data)\n  .join(\"\")\n```\n\nnodeType으로 텍스트노드만 필터링하여 해결하였다.\\\nnodeType이 3인 데이터가 해당 node의 Text정보다.\\\n[nodeType MDN](https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType)\n"}]}